{"meta":{"title":"Chor Ho's blog","subtitle":null,"description":"笔记心得记录","author":"Chan Chor Ho","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-04-16T16:15:36.792Z","updated":"2019-04-16T16:15:36.792Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"大三学生 开设个人博客主要是将自己遇到的难点错点记录在这里 目前在进行Spring、Mybatis、 Java高级内容的学习中 希望自己能坚持写下来，把这当成记录笔记、心得的地方，方便以后的查询。"},{"title":"","date":"2019-04-16T14:41:56.867Z","updated":"2019-04-16T14:41:56.867Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-04-16T14:42:53.952Z","updated":"2019-04-16T14:42:53.952Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"校园商铺平台开发","slug":"校园商铺平台开发","date":"2019-05-08T03:06:29.000Z","updated":"2019-05-08T03:06:29.413Z","comments":true,"path":"2019/205/08/校园商铺平台开发/","link":"","permalink":"http://yoursite.com/2019/205/08/校园商铺平台开发/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"图解HTTP记录","slug":"图解HTTP记录","date":"2019-05-01T13:14:54.000Z","updated":"2019-05-02T14:13:00.954Z","comments":true,"path":"2019/205/01/图解HTTP记录/","link":"","permalink":"http://yoursite.com/2019/205/01/图解HTTP记录/","excerpt":"","text":"WWW（万维网）构建技术分别为： 把SGML(标准通用标记语言)作为页面的文本标记语言的HTML(超文本标记语言)； 作为文档传输协议的HTTP； 指定文档所在地址的URL(统一资源定位符) 网络基础TCP/IPTCP/IP的分层管理TCP/IP协议簇按层次分别分为以下4层：应用层、传输层、网络层、数据链路层 分层的好处： 把各层的接口规划好之后，各个层次内部的设计能自由改动。 层次化之后，设计变得相对简单了，例如处于应用层上的应用可以只考虑分派给自己的任务，而不需要考虑对方在地球上哪个地方、传输路线、是否能确保传输送达等问题。 TCP/IP协议簇各层的作用应用层应用层决定了向用户提供应用服务时通信的活动。 TCP/IP协议簇内预存了各类通用的应用服务，比如FTP（File Transfer Protocol，文件传输协议）和DNS（Domain Name System，域名系统）服务就是其中两类。 HTTP协议也处于该层。 传输层传输层对上层应用层，提供处于网络连接中的两台计算机的数据传输。 在传输层有两个性质不同的协议TCP（Transmission Control Protocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。 网络层（又名网络互联层）网络层用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。 与对方的计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 链路层（又名数据链路层，网络接口层）用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。 TCP/IP通信传输流利用TCP/IP协议簇进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端从链路层往上走。 用HTTP举例说明 发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种把数据信息包装起来的做法称为封装。 与HTTP关系密切的协议：IP、TCP和DNS负责传输的IP协议IP（Internet Protocol）网际协议位于网络层。几乎所有使用网络的系统都会用到这个协议。 IP协议的作用是把各个数据包传送给对方。要保证确实传送到对方那里，其中两个重要的条件是IP地址和MAC地址（Media Access Control Address） 使用ARP协议凭借MAC地址进行通信ARP是一种用以解析地址的协议，根据通信方的IP地址就能反查出对应的MAC地址。 通常通信的双方是经过多台计算机和网络设备中转才连接到对方，在进行中转时，会利用下一站的MAC地址来搜索下一个中转目标，所以会采用ARP协议 没有人能够全面掌握互联网中的传输状况 在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只能获悉很粗略的传输路线。称为路由选择。 确保可靠性的TCP协议TCP位于传输层，提供可靠的字节流服务。 字节流服务：为了方便传输，将大块数据分割成报文段为单位的数据包进行管理。 可靠的传输服务：能够把数据准确可靠的传输给对方。发送端首先发送一个带有SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包表示传达确认信息。最后，发送方再回传一个带ACK标志的数据包代表“握手”结束。即三次握手策略。 负责域名解析的DNS服务DNS服务和HTTP协议一样位于应用层。提供域名到IP地址之间的解析服务。 各种协议与HTTP协议的关系","categories":[],"tags":[{"name":"http","slug":"http","permalink":"http://yoursite.com/tags/http/"}]},{"title":"Java多线程","slug":"Java多线程","date":"2019-05-01T05:52:49.000Z","updated":"2019-05-09T07:29:17.194Z","comments":true,"path":"2019/205/01/Java多线程/","link":"","permalink":"http://yoursite.com/2019/205/01/Java多线程/","excerpt":"","text":"进程、线程与任务1`&amp;ensp;`进程是程序的运行实例，例如一个运行eclipse就是一个进程；运行一个Java程序的实质是启动一个Java虚拟机的进程。 进程是程序的运行实例，例如一个运行eclipse就是一个进程；运行一个Java程序的实质是启动一个Java虚拟机的进程。 进程是程序向操作系统申请资源（如内存空间和文件句柄）的基本单位。 线程是进程中可独立执行的最小单位。例如程序为了提高其文件下载效率可以使用多个线程，这些线程各自独立地从服务器上下载大文件中的一段数据。 线程所要完成的计算就被称为任务，特定的线程总是在执行者特定的任务，任务代表线程要完成的工作。例如从服务器上下载一个文件、解压缩一批文件、解压缩一个文件等。 Java线程API简介Java标准库类java.lang.Thread就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。 线程的两种创建方式和区别线程的创建、启动与运行每个线程都有其要执行的任务。线程的任务处理逻辑可以在Thread类的run实例方法中直接实现或通过该方法进行调用，因此run方法相当于线程的任务处理逻辑的入口方法，它由Java虚拟机在运行响应线程时直接调用，而不是由应用代码进行调用。 运行一个线程实际上就是让Java虚拟机执行该线程的run方法，从而使线程的任务处理逻辑得以执行。为此要启动线程，Thread类的start方法的作用是启动响应的线程。启动一个线程的实质是请求Java虚拟机运行响应的线程，而这个线程具体何时能够运行就由线程调度机决定。因此，start方法调用结束并不意味着响应的线程已经开始运行，可能稍后才被运行，也有可能永远不会被运行。 Thread类的两个常用构造器：Thread（）和Thread（Runnable target）。相应的，创建线程有两种方式： 定义Thread类的子类，在该类中覆盖run方法并在该方法中实现线程任务处理逻辑 创建一个java.lang.Runnable接口的实例，并在该实例中的run方法实现任务处理逻辑，然后以该Runnable接口实例作为构造器的参数直接创建（new）一个Thread类的实例 不管以哪种方式创建线程，一旦线程的run方法执行（由Java虚拟机调用）结束，响应的线程的运行也就结束了。运行结束的线程所占用的资源（如内存空间）会如同其他Java对象一样被Java虚拟机垃圾回收。 线程属于”一次性用品“，我们不能通过重新调用一个已经运行结束的线程的start方法来冲i性能运行。事实上，start方法也只能够被调用一次，多次调用同一个Thread实例中的start方法会导致抛出IllegalThreadStateException异常。 在Java平台中，一个线程就是一个对象，对象的创建离不开内存空间的分配。创建一个线程与创建其他类型的Java对象不同的是，Java虚拟机会为每个线程分配调用栈（Call Stack）所需的内存空间；另外Java平台中的每个线程可能还有一个内核线程**，因此相对来说，创建线程对象比创建其他类型的对象的成本要高一些。 线程的run方法总是由Java虚拟机直接调用的，虽然Java语言并不阻止我们直接调用run方法，但是多数情况下我们不能这么做，因为这样做有违背创建线程的初衷（run方法运行在线程中） Runnable接口Runnable接口只定义了一个方法，该方法的声明如下： public void run() Runnable接口可以被看作任务进行的抽象，任务的处理逻辑就体现在run方法中。Thread类实际上就是Runnable接口的一个实现类，其对Runnable接口的实现如下： 12345public void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 因此Thread类的任务处理逻辑就是要么什么都不做（target == null），要么就直接执行target所引用的Runnable实例所实现的任务处理逻辑。 线程两种创建方式的区别","categories":[],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}]},{"title":"Spring-MVC相关记录","slug":"Spring-MVC相关记录","date":"2019-05-01T02:20:18.000Z","updated":"2019-05-01T06:15:40.833Z","comments":true,"path":"2019/205/01/Spring-MVC相关记录/","link":"","permalink":"http://yoursite.com/2019/205/01/Spring-MVC相关记录/","excerpt":"","text":"什么是MVC设计模式？–Controller：负责接收并处理请求，响应客户端。 –Model：模型数据，业务逻辑。 –View：呈现模型，与用户进行交互。 什么是SpringMVC？–Spring框架的一个后续产品，目前最好的实现MVC设计模式的框架。 –Spring框架的一个子模块，二者可以很好的结合使用，不需要整合 SpringMVC核心组件 DispatcherServlet：前置控制器 HandlerMapping：将请求映射到Handler Handler：后端控制器，完成具体业务逻辑 HandlerInterceptor：处理器拦截器 HandlerExecutionChain：处理器执行链 HandlerAdapter：处理器适配器 ModelAndView：装配模型数据和视图信息 ViewResolver：视图解析器 SpringMVC实现流程 客户端请求被DispatcherServlet接收 DispatcherServlet将请求映射到Handler 生成Handler以及HandlerInterceptor 返回HandlerExecutionChain（Handler+HandlerExecutionInterceptor） DispatcherServlet通过HandlerAdapter执行Handler 返回一个ModelAndView DispatcherServlet通过ViewResolver进行解析 返回填充了模型数据的View，响应给客户端 SpringMVC的使用–大部分组件由框架提供，开发者只需通过配置进行关联。 –开发者只需手动编写Handler，View","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring事务","slug":"Spring事务","date":"2019-04-23T05:32:08.000Z","updated":"2019-05-01T06:11:36.806Z","comments":true,"path":"2019/204/23/Spring事务/","link":"","permalink":"http://yoursite.com/2019/204/23/Spring事务/","excerpt":"","text":"Spring事务 Spring事务包括编程式事务和声明式事务 事务管理最佳实践选择 通用事务问题的解决方案","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring AOP相关零散笔记","slug":"Spring-AOP相关零散笔记","date":"2019-04-18T04:37:06.000Z","updated":"2019-05-01T06:11:58.497Z","comments":true,"path":"2019/204/18/Spring-AOP相关零散笔记/","link":"","permalink":"http://yoursite.com/2019/204/18/Spring-AOP相关零散笔记/","excerpt":"","text":"AOP相关术语例子： AOP的代理： Spring在运行期间，生成动态代理对象，不需要特殊的编译器 Spring AOP的底层 就是通过JDK动态代理或CGLib动态代理技术为目标Bean执行横向织入 若目标对象实现了若干接口，Spring使用JDK的java.lang.reflect.Proxy类代理。 若目标对象没有实现任何借口，Spring使用CGLib库生成目标对象的子类 *注意： 程序中应优先对接口创建代理，便于程序解耦维护（推荐面向接口式编程） 标记为final的方法，不能被代理，因为无法进行覆盖 Spring只支持方法连接点，不提供属性连接点（也就是只能对方法进行增强） 基于AspectJ的注解AOP开发简介： AspectJ是一个基于Java语言的AOP框架 @AspectJ通过JDK5注解技术，允许直接在Bean类中定义切面 使用AspectJ需要导入Spring AOP和AspectJ相关的jar包 可以通过注解方式或者XML方式开发","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Bean管理","slug":"Bean管理","date":"2019-04-17T10:09:48.000Z","updated":"2019-04-22T10:00:47.490Z","comments":true,"path":"2019/204/17/Bean管理/","link":"","permalink":"http://yoursite.com/2019/204/17/Bean管理/","excerpt":"","text":"Bean的作用域 类型 说明 singleton 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在 prototype 每次调用getBean()时都会返回一个新的实例 request 每次HTTP请求都有创建一个新的Bean，该作用域仅适合于WebApplicationContext环境 session 同一个HTTP Session共享一个Bean，不同HTTP Session使用不同的Bean。该作用域仅适用于WebApplicationContext环境 使用注解定义Bean @Component 描述Spring框架中的Bean 除了@Component外，Spring还提供了功能基本和@Component等效的注解 -@Repository 用于对DAO实现类进行标注 -@Service 用于对Service实现类进行标注 -@Controller 用于对Controller实现类进行标注 *这三个注解是为了让标注类本身的用途清晰，Spring在后续版本会对其增强 Spring的属性注入-注解方式 自动化装配Bean​ 类中使用了@ComponentScan注解。这个注解能在Spring中启动组件扫描，如果没有其他配置的话，@ComponentScan默认会扫描与配置类相同的包，因此Spring会扫描这个包以及这个包下的所有子包，查找带有@Component注解的类。这样的话，就能在Spring中自动为其创建Bean。 ​ 也可以通过XML启动组件扫描，&lt;context:component-scan&gt;元素有与@Component注解相应的属性和子元素。 1&lt;context:component-scan base-package=&quot;xxx&quot;/&gt; //xxx对应的是包的名称 @Resource注解为空指针解决:因为maven配置文件的pom.xml文件中缺少javax.annotation的依赖,在pom.项目路中加入依赖即可 12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;","categories":[],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Mybatis常用对象SqlSessionFactory、SqlSession","slug":"Mybatis常用对象SqlSessionFactory、SqlSession","date":"2019-04-17T07:43:56.000Z","updated":"2019-04-17T07:55:39.339Z","comments":true,"path":"2019/204/17/Mybatis常用对象SqlSessionFactory、SqlSession/","link":"","permalink":"http://yoursite.com/2019/204/17/Mybatis常用对象SqlSessionFactory、SqlSession/","excerpt":"","text":"每个基于 MyBatis 的应用都是以一个 SqlSessionFactory的实例为核心的从 XML 中构建 SqlSessionFactory​ SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder获得。而SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的Configuration 的实例构建出 SqlSessionFactory 的实例。 ​ 从 XML 文件中构建 SqlSessionFactory的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流（InputStream）实例，包括字符串形式的文件路径或者 file:// 的 URL 形式的文件路径来配置。MyBatis 包含一个名叫 Resources的工具类，它包含一些实用方法，可使从 classpath 或其他位置加载资源文件更加容易。 1234String resource = \"org/mybatis/example/mybatis-config.xml\";InputStream inputStream = Resources.getResourceAsStream(resource);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); ​ XML 配置文件中包含了对 MyBatis系统的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，这里先给出一个简单的示例： 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"org/mybatis/example/BlogMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; ​ 当然，还有很多可以在 XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，它用来验证 XML 文档正确性。environment元素体中包含了事务管理和连接池的配置。mappers 元素则是包含一组映射器（mapper），这些映射器的XML 映射文件包含了 SQL 代码和映射定义信息。 不使用 XML 构建 SqlSessionFactory​ 如果你更愿意直接从 Java 代码而不是 XML 文件中创建配置，或者想要创建你自己的配置构建器，MyBatis也提供了完整的配置类，提供所有和 XML 文件相同功能的配置项。 1234567DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();TransactionFactory transactionFactory = new JdbcTransactionFactory();Environment environment = new Environment(\"development\", transactionFactory, dataSource);Configuration configuration = new Configuration(environment);configuration.addMapper(BlogMapper.class);SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration); ​ 注意该例中，configuration 添加了一个映射器类（mapper class）。映射器类是Java 类，它们包含 SQL 映射语句的注解从而避免依赖 XML 文件。不过，由于Java 注解的一些限制以及某些 MyBatis 映射的复杂性，要使用大多数高级映射（比如：嵌套联合映射），仍然需要使用 XML配置。有鉴于此，如果存在一个同名XML 配置文件，MyBatis 会自动查找并加载它（在这个例子中，基于类路径和 BlogMapper.class 的类名，会加载BlogMapper.xml）。具体细节稍后讨论。 从 SqlSessionFactory 中获取 SqlSession​ 既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。SqlSession完全包含了面向数据库执行 SQL 命令所需的所有方法。你可以通过SqlSession 实例来直接执行已映射的 SQL 语句。例如： 123456SqlSession session = sqlSessionFactory.openSession();try &#123; Blog blog = (Blog)session.selectOne(\"org.mybatis.example.BlogMapper.selectBlog\", 101);&#125; finally &#123; session.close();&#125; ​ 诚然，这种方式能够正常工作。不过现在有了一种更简洁的方式——使用正确描述每个语句的参数和返回值的接口（比如BlogMapper.class），你现在不仅可以执行更清晰和类型安全的代码，而且还不用担心易错的字符串字面值以及强制类型转换。 例如： 1234567SqlSession session = sqlSessionFactory.openSession();try &#123; BlogMapper mapper = session.getMapper(BlogMapper.class); Blog blog = mapper.selectBlog(101);&#125; finally &#123; session.close();&#125; 现在我们来探究一下这里到底是怎么执行的。 探究已映射的 SQL 语句详细： ​ http://www.mybatis.org/mybatis-3/zh/getting-started.html","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"Mybatis零散记录","slug":"Mybatis零散记录","date":"2019-04-17T05:58:15.000Z","updated":"2019-04-18T04:25:30.091Z","comments":true,"path":"2019/204/17/Mybatis零散记录/","link":"","permalink":"http://yoursite.com/2019/204/17/Mybatis零散记录/","excerpt":"","text":"使用resultMap解决数据库字段和实体类字段不一致的情况​ 我们直接从user表中查询一条数据出来，查询的结果是一个user对象，即mybatis会自动帮我们把查询的结果转为一个user对象，那么mybatis在转化的过程中怎么知道数据库的哪个字段对应JavaBean中的哪个属性呢？很简单，只要两者的名称一样，系统就能就能自动识别出来，那么在实际开发中，JavaBean中的属性命名我们习惯于驼峰命名法，在数据库中我们更常用下划线命名法。例如在实体类中User对象中的userName，数据库中的user_name,如果直接使用Select查询中，Mybatis就没法帮我们将我们想要的结果查询出来了。这时候可以使用resultMap来解决。​ resultMap可以用来描述从数据库结果集中来加载对象，有的时候映射过于复杂，我们可以在Mapper中定义resultMap来解决映射问题。当然resultMap还有其他用法​ 在上面的问题中，可以在userMapper中这样定义一个resultMap：​ 1234&lt;resultMap id=\"userMap\" type=\"org.sang.bean.User\"&gt; &lt;id property=\"id\" column=\"id\" javaType=\"long\" jdbcType=\"NUMERIC\"/&gt; &lt;result property=\"userName\" column=\"user_name\" javaType=\"string\" jdbcType=\"VARCHAR\"/&gt; &lt;/resultMap&gt; 关于这个resultMap： 首先我们给resultMap去了一个id，这个id是resultMap的唯一标识符，我们在后面引用这个resultMap的时候就是通过这个id来引用，然后还定义了type属性，type属性指明了这个resultMap它对应的是哪个JavaBean。 在resultMap节点中，id表示哪个字段代表这主键，result节点定义了普通的映射关系，这里的property表示JavaBean中的属性名称，column表示数据库中的字段名称，javaType代表JavaBean中该属性的类型，jdbcType则表示数据库中该字段的类型 如此定义后，我们只需要在select查询的时候指定resultMap即可： 123&lt;select id=\"getUser\" resultMap=\"userMap\" parameterType=\"Long\"&gt; select * from user2 where id = #&#123;id&#125; &lt;/select&gt; *也可以通过id配置的方式来解决数据库主键和实体类主键不一致的情况 1&lt;id column=\"\" property=\"\"&gt;&lt;/id&gt; 同样，column表示数据库中的字段名称，property表示实体类中的属性名称","categories":[],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://yoursite.com/tags/Mybatis/"}]},{"title":"剑指Java面试-Java底层知识：JVM","slug":"剑指Java面试-Java底层知识：JVM","date":"2019-04-15T08:08:07.000Z","updated":"2019-04-16T14:40:27.386Z","comments":true,"path":"2019/204/15/剑指Java面试-Java底层知识：JVM/","link":"","permalink":"http://yoursite.com/2019/204/15/剑指Java面试-Java底层知识：JVM/","excerpt":"","text":"","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"剑指Java面试-计算机网络面试核心","slug":"剑指Java面试-计算机网络面试核心","date":"2019-04-15T07:49:02.000Z","updated":"2019-04-16T14:40:39.640Z","comments":true,"path":"2019/204/15/剑指Java面试-计算机网络面试核心/","link":"","permalink":"http://yoursite.com/2019/204/15/剑指Java面试-计算机网络面试核心/","excerpt":"","text":"","categories":[],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"http://yoursite.com/tags/计算机网络/"}]},{"title":"a","slug":"a","date":"2019-04-13T16:57:55.000Z","updated":"2019-04-16T14:40:13.659Z","comments":true,"path":"2019/204/14/a/","link":"","permalink":"http://yoursite.com/2019/204/14/a/","excerpt":"","text":"测试发布的第一篇文章","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://yoursite.com/tags/test/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-04-13T07:51:22.411Z","updated":"2019-04-13T16:54:07.564Z","comments":true,"path":"2019/204/13/hello-world/","link":"","permalink":"http://yoursite.com/2019/204/13/hello-world/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}